#!/usr/bin/env python
#    This code is a portion of frigate Event Video Recorder (fEVR)
#
#    Copyright (C) 2021-2022  The Bearded Tek (http://www.beardedtek.com) William Kenny
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU AfferoGeneral Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

from urllib.parse import _NetlocResultMixinStr
from paho.mqtt import client as mqtt_client
import argparse
from os import path, access, R_OK
from os import remove as rmFile
from time import time
from math import floor
from random import randint
import socket
import requests
from math import floor
import socket
import json
import yaml
import sys
from datetime import datetime
import apprise
import pytz

class convert:
    def convertTZ(time,clockFmt=12,Timezone="America/Anchorage",format="%m/%d/%y %I:%M:%S %p",purpose="display"):
        dt_utc = time.replace(tzinfo=pytz.UTC)
        dt = dt_utc.astimezone(pytz.timezone(Timezone))
        if clockFmt == 12:
            if purpose == "display":
                format = "%m/%d/%y %I:%M:%S %p"
            elif purpose == "filename":
                format = "%m-%d-%y_%I-%M-%S_%p"
        else:
            if purpose == "display":
                format = "%m/%d/%y %H:%M:%S"
            elif purpose == "filename":
                format = "%m-%d-%y_%H-%M-%S"
        tzString = dt.strftime(format).lower()
        return tzString
    
class notifications:
    def __init__(self,config={}):
        self.config = config['notifications']
        self.fevr = config['fevr']
        self.mqtt = config['mqtt']
        self.timezone = config['timezone']
        self.verbose = config['verbose']
        self.cooldownTime = self.config['cooldown']  # Cooldown period so we don't overload notifications
        self.source = f"MQTT | APPRISE"
        
    def cooldown(self,camera,label):
        last = self.notification['last'][camera] if camera in self.notification['last'] else self.notification['last']['default']
        byTime = True if (last['time'] + self.cooldownTime) > time() else False
        byType = True if last['type'] == 'end' else False
        byLabel = True if last['label'] == label else False
        # All must be true to enter cooldown period for this camera.
        return True if byTime and byType and byLabel else False
        
    def setup(self):
        self.notification = {
            "source": "apprise",
            "server": None,
            "topic": None,
            "data": None,
            "title": None,
            "message": None,
            "priority": 3,
            "tags": None,
            "delay": None,
            "actions": None,
            "click": None,
            "attach": None,
            "filename": None,
            "email": None,
            "cache": None,
            "username": None,
            "password": None,
            "last": {
                "default":{
                "time"  : 0,
                "id"    : "",
                "label" : "",
                "type"  : ""
                }
            }
        }
        if self.verbose:
            logit.execute('    Notification Options:', src='MQTT | APPRISE')
        for key in self.config:
            self.notification[key] = self.config[key] if key in self.config else None
            if self.verbose:
                if self.notification[key]:
                    logit.execute(f"      {key}: {self.config[key]}", src='MQTT | APPRISE')
            
    def notify(self,event):
    # Carries out notifications event: event json from mqtt:frigate/events
        if self.config['enabled']:
        # check if notifications are enabled
            target = "after" if event['type'] == "end" else "before"
            camera = event[target]['camera']
            label = event[target]['label']
            eventType = event['type']
            eventid = event[target]['id']
            nTime = int(time())
            dateobj = datetime.fromtimestamp(nTime)
            filedate = convert.convertTZ(dateobj,purpose='filename',Timezone=self.timezone)
            displaydate = convert.convertTZ(dateobj,Timezone=self.timezone)

            if not self.cooldown(camera,label):
            # Check if we are in a cooldown period for this camera and event
                # Craft our message
                message = f"{displaydate}: {label} detected in {camera}"
                # Determine which data to send
                if eventType == "end":
                # Get event video clip if event is over
                    filename = f"apprise-{filedate}-clip.mp4"
                    dataURL = f"http://localhost/api/event/clip/{eventid}"
                else:
                # Take snapshot from camera if event is not over
                    filename = f"{filedate}-snapshot.jpg"
                    dataURL = f"http://localhost/api/cameras/{camera}/snapshot/320"
                if self.verbose:
                    logit.execute(f"dataURL: {dataURL}",src=self.source)
#                # Authenticate with fEVR
#                rSession = requests.Session()
#                if auth(url=f"{self.fevr['url']}",apikey=self.mqtt['apikey'],rSession=rSession).api():
#                    # Get Snapshot
#                    try:
#                        data = rSession.get(dataURL, allow_redirects=True).content
#                        with open(f'/tmp/{filename}','wb') as attachment:
#                            logit.execute(f"Notification Attachment: /tmp/apprise/{filename}",src=self.source)
#                            attachment.write(data)
#                        message = f"{displaydate}: {label} detected in {camera}"
#                    except requests.ConnectionError as e:
#                        message = f"Error obtaining snapshot Error: {e}"
#                        self.notification['data'] = message
#                        logit.execute(message,src=self.source)
                # Build Notification
                appriseObj = apprise.Apprise()
                attach = f"/tmp/{filename}"
                title = f"fEVR: {self.fevr['name']}"
                body = message
                priorityLevels = ['none','min','low','default','high','max']
                priority = priorityLevels[self.notification['priority']]
                action = f"view, View Event, https://192.168.2.240:5090/event/{eventid}/snap,clear=false;"
                URL = f"{self.notification['server']}?priority={priority}&action={action}&filename={filename}"
                appriseObj.add(self.notification['server'])
                try:
                    result = appriseObj.notify(
                        attach=dataURL,
                        title=title,
                        body=body
                        )
                    logit.execute("Apprise Notification Success",src=self.source)
                    logit.execute(f"    {result}")
                    if self.verbose:
                        for key in self.notification:
                            if self.notification[key]:
                                logit.execute(f"{key}: {self.notification[key]}",src=self.source)
                        logit.execute(f"attachments: {attach}",src=self.source)
                except Exception as error:
                    logit.execute("Apprise Notification Failure",self.source)
                    logit.execute(f"Error: {error}",self.source)

class logit:
    def execute(msg,src='fEVR',debug=True):
        def to_stderr(*a):
            print(*a, file=sys.stderr)
        logtime = "{:.2f}".format(time())
        logentry = f"{logtime} {str(msg)}"
        if debug:
            to_stderr(f"[ {src:16} ] {logentry}")

class getLocalIP:
    def __init__(self,url):
        if "://" in url:
            host = url.split(":")[1].replace("//","")
        else:
            host = "1.1.1.1"
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((host, 80))
        self.addr = s.getsockname()[0]

class auth:
    def __init__(self,url="http://localhost:5090",rSession=requests.Session(),apikey=""):
        self.url = url
        self.rSession = rSession
        self.apikey = apikey
        self.myip = getLocalIP(self.url)

    def api(self):
        source = "MQTT | AUTH"
        # Construct the json for the post request
        JsonPost = {'key':self.apikey,'ip':self.myip.addr}
        # Send the post using our session
        fevrUrl = f"{self.url}/apiAuth"
        apiAuth = self.rSession.post(f"{fevrUrl}", json=JsonPost)
        apiAuthJSON = json.loads(apiAuth.content)
        authResult = True if apiAuthJSON['auth'] else False
        logit.execute(f"{fevrUrl} {authResult}: {apiAuthJSON['authIP']} name: {apiAuthJSON['name']}",src=source)
        return authResult
    
class fevrMQTT:
    def __init__(self,configFile='data/config.yml'):
        self.source = "MQTT | DEFAULTS"
        hostname = socket.gethostname()
        self.clientID = f"fevr-{hostname}-{randint(0,100)}"
        # Initialize our Config variable as a dict and set sane default values in self.defaultConfig
        self.defaultConfig = {
                    "fevr":{
                            "url"  : "http://localhost:5090",
                            "name" : "fEVR"
                           },
                    "mqtt":{
                            "enabled"   : True,
                            "host"      : "localhost",
                            "port"      : "1883",
                            "user"      : None,
                            "password"  : None,
                            "topics"    : ['frigate/+'],
                            "apikey"    : None
                           },
                    "notifications":{
                            "enabled": False,
                            "cooldown": 30,
                            "priority": 4,
                            "server": "https://ntfy.fevr.video",
                           },
                    "verbose": True,
                    "timezone": "America/Anchorage"
        }
        # Get the Command Line Arguments in a dict
        self.Args = self.cla()
        # If using the -c/--config option, get the config from the specified file
        
        self.config = self.getConfig(self.Args['config']) if self.Args['config'] else self.getConfig(configFile)
        self.setup()
        self.run()
        
    def getConfig(self,config):
        source = "MQTT | CONFIG"
        if path.isfile(config) and access(config, R_OK):
            with open(config) as configFile:
                try:
                    Config = yaml.safe_load(configFile)
                except Exception as e:
                    logit.execute(f"ERROR: {e}",src=source)
                    Config = {}
            Config["error"] = None
        else:
            if path.isfile(config):
                Config["error"] = "File not readable"
            Config["error"] = "File does not exist"
        return self.validateConfig(Config)
    
    def validateConfig(self,Config={}):
        for key in ["mqtt","fevr","notifications","verbose"]:
            if key in Config:
                if key == "mqtt":
                    for subkey in ["host","port","user","password","topics","apikey"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "fevr":
                    for subkey in ["url"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "notifications":
                    for subkey in ["enabled","cooldown","server"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]            
            else:
                try:
                    Config[key] = self.defaultConfig[key]
                except:
                    Config[key] = None
        return Config
    
    def cla(self):
        source = "MQTT | CMDLINE"
        parser = argparse.ArgumentParser()
        parser.add_argument('-c','--config',type=str,required=False,help="If set, uses command line options instead of the database (default: empty)")
        parser.add_argument('-v','--verbose',action='store_true',required=False,help="If set, outputs verbosely to stdout")
        args = parser.parse_args()
        logit.execute(vars(args),src=source)
        return vars(args)
    
    def parseTopics(self):
        source = "MQTT | TOPICS"
        excluded = None
        Topics = self.config['mqtt']['topics'].split(',',5)
        topics = []
        count=0
        for topic in Topics:
            if 4 >= count:
                topics.append(topic)
            else:
                if 5 == count:
                    excluded = f"Topic Limit Exceeded. Excluded Topics: "
                excluded += f"'{topic}' "
        if excluded:
            logit.execute(f"Only 5 topics allowd.  Excluded Topics: {excluded}",src=source)
        return topics
    
    def setup(self):
        source = "MQTT | SETUP"
        
        # Parse the topics into a list if it's a string.
        if isinstance(self.config['mqtt']['topics'],str):
            self.config['mqtt']['topics'] = self.parseTopics()
        
        #Setup Notifications:
        self.notify = notifications(config=self.config)
        self.notify.setup()
        
    def connect_mqtt(self) -> mqtt_client:
        def on_connect(client, userdata, flags, rc):
            source = "MQTT | CONNECT"
            if rc == 0:
                logit.execute(f"Connected to {self.config['mqtt']['host']}:{self.config['mqtt']['port']} as {self.clientID}",src=source)
            else:
                logit.execute("Failed to connect, return code %d", rc,src=source)
        client = mqtt_client.Client(self.clientID)
        if self.config['mqtt']['user'] and self.config['mqtt']['password']:
            client.username_pw_set(self.config['mqtt']['user'], self.config['mqtt']['password'])
        client.on_connect = on_connect
        client.connect(self.config['mqtt']['host'], self.config['mqtt']['port'])
        return client
    
    def addEvent(self,event):
        #Adds an event to fEVR from frigate
        source = "MQTT | AddEvent"
        # Create a session variable, authenticate, and tell fEVR via it's API to get the event.
        rSession = requests.Session()
        Auth = auth(url=self.config['fevr']['url'],apikey=self.config['mqtt']['apikey'],rSession=rSession)
        if Auth.api():
            fEVRurl = f"{self.config['fevr']['url']}/api/events/add/{event['id']}/{event['camera']}/{event['label']}/{floor(float(event['score'])*100)}"
            addEventResponse = rSession.get(fEVRurl)
            respJSON = json.loads(addEventResponse.content)
            if self.config['verbose']:
                logit.execute(fEVRurl,src=source)
            if respJSON["error"] == 0:
                LogMsg = f"SUCCESS: {event['id']} ({event['label']} in {event['camera']}) added"
            else: 
                LogMsg = f"FAILURE: {respJSON}"
            logit.execute(LogMsg,src="MQTT | EVENT ADD")
        else:
            if 'fEVRurl' in locals():
                logit.execute(f"Failed to Authenticate - visit {fEVRurl}/profile to generate an API Auth Key and insert it in your config", src="MQTT | ERROR")
            else:
                logit.execute(f"It appears your instance of fEVR is not setup yet.  please visit `/setup` to complete setup.", src="MQTT | ERROR")
    
    def processMsg(self,msg,topic):
        '''
        If we receive a message from the server we check if it matches our watched topics
        If it does, we respond
        '''
        if 'available' in topic:
            source = "MQTT | STATUS"
        # If frigate says its available, we output to the logs
            logit.execute('frigate is online',src=source)
        elif 'event' in topic:
            source = "MQTT | EVENT"
            # If it's an event we take action
            event = json.loads(msg)
            eventfound = event["after"]["id"]
            # Log the event
            if self.config['verbose']:
                logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            else:
                if event['type'] == "new" or event['type'] == "end":
                    logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            # Take Action on the event
            if event['type'] == "new":
                # Trigger Notification
                self.notify.notify(event)
            elif event['type'] == 'end':
                # Use event['after'] to add event
                self.addEvent(event['after'])
                self.notify.notify(event)
    def subscribe(self, client: mqtt_client):
        def on_message(client, userdata, msg):
            self.processMsg(msg.payload.decode(),msg.topic)
        for topic in self.config['mqtt']['topics']:
            source = "MQTT | SUBSCRIBE"
            logit.execute(f"Subscribing to: {topic}",src=source)
            client.subscribe(topic)
        client.on_message = on_message
    def run(self):
        self.client = self.connect_mqtt()
        self.subscribe(self.client)
        self.client.loop_forever()
if __name__ == '__main__':
    fevrMQTT()