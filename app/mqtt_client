#!/usr/bin/env python
#    This code is a portion of frigate Event Video Recorder (fEVR)
#
#    Copyright (C) 2021-2022  The Bearded Tek (http://www.beardedtek.com) William Kenny
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU AfferoGeneral Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

from urllib.parse import _NetlocResultMixinStr
from paho.mqtt import client as mqtt_client
import argparse
from os import path, access, R_OK
from time import time
from math import floor
from random import randint
import socket
import requests
from math import floor
import socket
import json
import yaml
import sys
from datetime import datetime

class notifications:
    def __init__(self,config={}):
        self.config = config['notifications']
        self.fevr = config['fevr']
        self.mqtt = config['mqtt']
        self.service = self.config['service']    # Which service to use
        self.cooldownTime = self.config['cooldown']  # Cooldown period so we don't overload notifications
        self.snap = None                    # Does Snapshot Exist?
        self.clip = None                    # Does Clip Exist
        self.event = None                   # Event dict from mqtt event
        self.lastnotify = {
            "default":
                {
                    "time"  : 0,            # int(time())
                    "id"    : "",           # event id
                    "label" : "",           # person, animal, car, etc...
                    "type"  : ""            # new update or end
                }
        }
        self.lastnotification = 0
        self.source = f"MQTT | {self.service}"
        self.configured = False
        
    def cooldown(self,camera,label):
        last = self.lastnotify[camera] if camera in self.lastnotify else self.lastnotify['default']
        byTime = True if (last['time'] + self.cooldownTime) > time() else False
        byType = True if last['type'] == 'end' else False
        byLabel = True if last['label'] == label else False
        # All must be true to enter cooldown period for this camera.
        return True if byTime and byType and byLabel else False
        
        
        
    def setup(self):
        if self.service == "ntfy":
            try:
                self.ntfy()
                self.configured = True
            except Exception as error:
                pass
        entry = f"{self.service.title()} configured and ready" if self.configured else f"{self.service.title()} not configured.  Error: {error}"
        logit.execute(entry,src=self.source)
   
    def ntfy(self):
        self.source = "MQTT | ntfy"
        self.server = "https://ntfy.fevr.video"
        self.topic = f"{self.config['topic']}"
        self.data = None
        self.headers =  {
                            "Title": "",
                            "Message": "",
                            "Priority": "3",
                            "Tags": None,
                            "Delay": None,
                            "Actions": None,
                            "Click": None,
                            "Attach": None,
                            "Filename": None,
                            "Email": None,
                            "Cache": None,
                            "Firebase": None,
                            "UnifiedPush": None,
                            "Poll-ID": None,
                            "Authorization": None
                        }
        
    def notify(self,event):
    # Carries out notifications event: event json from mqtt:frigate/events
        if self.config['enabled']:
        # check if notifications are enabled
            target = "after" if event['type'] == "end" else "before"
            camera = event[target]['camera']
            label = event[target]['label']
            eventType = event['type']
            eventid = event[target]['id']
            nTime = int(time())
            dateobj = datetime.fromtimestamp(nTime)
            datestr = dateobj.strftime("%m/%d/%y")
            timestr = dateobj.strftime("%H:%M:%S")
            filedate = dateobj.strftime("%Y-%m-%d_%H-%M-%S")
            
            if not self.cooldown(camera,label):
            # Check if we are in a cooldown period for this camera and event
                # Determine which data to send
                if eventType == "end":
                # Get event video clip if event is over
                    filename = f"{filedate}-clip.mp4"
                    dataURL = f"{self.fevr['url']}/api/event/clip/{eventid}"
                else:
                # Take snapshot from camera if event is not over
                    filename = f"{filedate}-snapshot.jpg"
                    dataURL = f"{self.fevr['url']}/api/cameras/{camera}/snapshot/320"
                
                rSession = requests.Session()
                if auth(url=f"{self.fevr['url']}",apikey=self.mqtt['apikey'],rSession=rSession).api():
                # Authenticate with fEVR
                    #If authenticated, get notification data
                    self.data = rSession.get(dataURL).content
                    self.headers['Filename'] = f""
                    self.headers['Title'] = f"fEVR: {self.fevr['name']}"
                    self.headers['Message'] = f"{datestr} - {label} detected in {camera} at {timestr}"
                    self.headers['Priority'] = f"{self.config['priority']}"
                    self.headers['Action'] = f"view, View Event, https://192.168.2.240:5090/event/{eventid}/snap,clear=false;"
                    try:
                        # Set notification url
                        nURL = f"{self.config['server']}/{self.config['topic']}"
                        requests.put(nURL,data=self.data,headers=self.headers)
                        # Set last notification data
                        self.lastnotify[camera] = {
                            "time"  : nTime,
                            "id"    : eventid,
                            "label" : label,
                            "type"  : eventType
                        }
                        # Log the successful notification
                        logit.execute(f"{nURL}: Notification SUCCESS",src=self.source)
                    except Exception as error:
                        # Log the failed notification
                        logit.execute(f"{nURL}: Notification FAILED",src=self.source)
                        logit.execute(f"Error: {error}",src=self.source)

class logit:
    def execute(msg,src='fEVR',debug=True):
        def to_stderr(*a):
            print(*a, file=sys.stderr)
        logtime = "{:.2f}".format(time())
        logentry = f"{logtime} {str(msg)}"
        if debug:
            to_stderr(f"[ {src:16} ] {logentry}")

class getLocalIP:
    def __init__(self,url):
        if "://" in url:
            host = url.split(":")[1].replace("//","")
        else:
            host = "1.1.1.1"
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((host, 80))
        self.addr = s.getsockname()[0]

class auth:
    def __init__(self,url="http://localhost:5090",rSession=requests.Session(),apikey=""):
        self.url = url
        self.rSession = rSession
        self.apikey = apikey
        self.myip = getLocalIP(self.url)

    def api(self):
        source = "MQTT | AUTH"
        # Construct the json for the post request
        JsonPost = {'key':self.apikey,'ip':self.myip.addr}
        # Send the post using our session
        fevrUrl = f"{self.url}/apiAuth"
        apiAuth = self.rSession.post(f"{fevrUrl}", json=JsonPost)
        apiAuthJSON = json.loads(apiAuth.content)
        authResult = True if apiAuthJSON['auth'] else False
        logit.execute(f"{fevrUrl} {authResult}: {apiAuthJSON['authIP']} name: {apiAuthJSON['name']}",src=source)
        return authResult
    
class fevrMQTT:
    def __init__(self,configFile='data/config.yml'):
        self.source = "MQTT | DEFAULTS"
        hostname = socket.gethostname()
        self.clientID = f"fevr-{hostname}-{randint(0,100)}"
        # Initialize our Config variable as a dict and set sane default values in self.defaultConfig
        self.defaultConfig = {
                    "fevr":{
                            "url"  : "http://localhost:5090",
                            "name" : "fEVR"
                           },
                    "mqtt":{
                            "enabled"   : True,
                            "host"      : "localhost",
                            "port"      : "1883",
                            "user"      : None,
                            "password"  : None,
                            "topics"    : ['frigate/+'],
                            "apikey"    : None
                           },
                    "notifications":{
                            "enabled": True,
                            "cooldown": 30,
                            "priority": 4,
                            "service": "ntfy",
                            "server": "https://ntfy.fevr.video",
                            "topic"     : f"fEVR-{socket.gethostname()}"
                           },
                    "verbose": True
        }
        # Get the Command Line Arguments in a dict
        self.Args = self.cla()
        # If using the -c/--config option, get the config from the specified file
        
        self.config = self.getConfig(self.Args['config']) if self.Args['config'] else self.getConfig(configFile)
        self.setup()
        self.run()
        
    def getConfig(self,config):
        source = "MQTT | CONFIG"
        if path.isfile(config) and access(config, R_OK):
            with open(config) as configFile:
                try:
                    Config = yaml.safe_load(configFile)
                except Exception as e:
                    logit.execute(f"ERROR: {e}",src=source)
                    Config = {}
            Config["error"] = None
        else:
            if path.isfile(config):
                Config["error"] = "File not readable"
            Config["error"] = "File does not exist"
        return self.validateConfig(Config)
    
    def validateConfig(self,Config={}):
        for key in ["mqtt","fevr","notifications","verbose"]:
            if key in Config:
                if key == "mqtt":
                    for subkey in ["host","port","user","password","topics","apikey"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "fevr":
                    for subkey in ["url"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "notifications":
                    for subkey in ["enabled","cooldown","service","server","topic"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]            
            else:
                try:
                    Config[key] = self.defaultConfig[key]
                except:
                    Config[key] = None
        return Config
    
    def cla(self):
        source = "MQTT | CMDLINE"
        parser = argparse.ArgumentParser()
        parser.add_argument('-c','--config',type=str,required=False,help="If set, uses command line options instead of the database (default: empty)")
        parser.add_argument('-v','--verbose',action='store_true',required=False,help="If set, outputs verbosely to stdout")
        args = parser.parse_args()
        logit.execute(vars(args),src=source)
        return vars(args)
    
    def parseTopics(self):
        source = "MQTT | TOPICS"
        excluded = None
        Topics = self.config['mqtt']['topics'].split(',',5)
        topics = []
        count=0
        for topic in Topics:
            if 4 >= count:
                topics.append(topic)
            else:
                if 5 == count:
                    excluded = f"Topic Limit Exceeded. Excluded Topics: "
                excluded += f"'{topic}' "
        if excluded:
            logit.execute(f"Only 5 topics allowd.  Excluded Topics: {excluded}",src=source)
        return topics
    
    def setup(self):
        source = "MQTT | SETUP"
        
        # Parse the topics into a list if it's a string.
        if isinstance(self.config['mqtt']['topics'],str):
            self.config['mqtt']['topics'] = self.parseTopics()
        
        #Setup Notifications:
        self.notify = notifications(config=self.config)
        self.notify.setup()
        
    def connect_mqtt(self) -> mqtt_client:
        def on_connect(client, userdata, flags, rc):
            source = "MQTT | CONNECT"
            if rc == 0:
                logit.execute(f"Connected to {self.config['mqtt']['host']}:{self.config['mqtt']['port']} as {self.clientID}",src=source)
            else:
                logit.execute("Failed to connect, return code %d", rc,src=source)
        client = mqtt_client.Client(self.clientID)
        if self.config['mqtt']['user'] and self.config['mqtt']['password']:
            client.username_pw_set(self.config['mqtt']['user'], self.config['mqtt']['password'])
        client.on_connect = on_connect
        client.connect(self.config['mqtt']['host'], self.config['mqtt']['port'])
        return client
    
    def addEvent(self,event):
        #Adds an event to fEVR from frigate
        source = "MQTT | AddEvent"
        # Create a session variable, authenticate, and tell fEVR via it's API to get the event.
        rSession = requests.Session()
        Auth = auth(url=self.config['fevr']['url'],apikey=self.config['mqtt']['apikey'],rSession=rSession)
        if Auth.api():
            fEVRurl = f"{self.config['fevr']['url']}/api/events/add/{event['id']}/{event['camera']}/{event['label']}/{floor(float(event['score'])*100)}"
            addEventResponse = rSession.get(fEVRurl)
            respJSON = json.loads(addEventResponse.content)
            if self.config['verbose']:
                logit.execute(fEVRurl,src=source)
            if respJSON["error"] == 0:
                LogMsg = f"SUCCESS: {event['id']} ({event['label']} in {event['camera']}) added"
            else: 
                LogMsg = f"FAILURE: {respJSON}"
            logit.execute(LogMsg,src="MQTT | EVENT ADD")
        else:
            if 'fEVRurl' in locals():
                logit.execute(f"Failed to Authenticate - visit {fEVRurl}/profile to generate an API Auth Key and insert it in your config", src="MQTT | ERROR")
            else:
                logit.execute(f"It appears your instance of fEVR is not setup yet.  please visit `/setup` to complete setup.", src="MQTT | ERROR")
    
    def processMsg(self,msg,topic):
        '''
        If we receive a message from the server we check if it matches our watched topics
        If it does, we respond
        '''
        if 'available' in topic:
            source = "MQTT | status"
        # If frigate says its available, we output to the logs
            logit.execute('frigate is online',src=source)
        elif 'event' in topic:
            source = "MQTT | EVENT"
            # If it's an event we take action
            event = json.loads(msg)
            eventfound = f"\n{json.dumps(event)}" if self.config['verbose'] else event["after"]["id"]
            # Log the event
            if self.config['verbose']:
                logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            else:
                if event['type'] == "new" or event['type'] == "end":
                    logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            # Take Action on the event
            if event['type'] == "new":
                # Trigger Notification
                self.notify.notify(event)
            elif event['type'] == 'end':
                # Use event['after'] to add event
                self.addEvent(event['after'])
                self.notify.notify(event)
    def subscribe(self, client: mqtt_client):
        def on_message(client, userdata, msg):
            source = "MQTT | RCVD"
            ## This is where our code goes to do what we want when a message is received
            if self.config['verbose']:
                logit.execute(f"{msg.topic}: Message Received",src=source)
            self.processMsg(msg.payload.decode(),msg.topic)
        for topic in self.config['mqtt']['topics']:
            source = "MQTT | SUBSCRIBE"
            logit.execute(f"Subscribing to: {topic}",src=source)
            client.subscribe(topic)
        client.on_message = on_message
    def run(self):
        self.client = self.connect_mqtt()
        self.subscribe(self.client)
        self.client.loop_forever()
if __name__ == '__main__':
    fevrMQTT()