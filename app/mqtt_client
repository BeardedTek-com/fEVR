#!/usr/bin/env python
#    This code is a portion of frigate Event Video Recorder (fEVR)
#
#    Copyright (C) 2021-2022  The Bearded Tek (http://www.beardedtek.com) William Kenny
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU AfferoGeneral Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

from paho.mqtt import client as mqtt_client
import argparse
from os import getenv, environ, path, access, R_OK
from time import time
from json import loads, dumps
from math import floor
from random import randint
import socket
import requests
from math import floor
from logit import logit
import socket
import json
import yaml

class getLocalIP:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    addr = s.getsockname()[0]

class auth:
    def __init__(self,transport="http://",fevr="localhost:5090",rSession=requests.Session(),apikey=""):
        self.transport = transport
        self.fevr = fevr
        self.rSession = rSession
        self.apikey = apikey
        self.script = "MQTT | auth"
        self.api()

    def api(self):
        # Construct the json for the post request
        JsonPost = {'key':self.apikey,'ip':getLocalIP.addr}
        # Send the post using our session
        fevrUrl = f"{self.transport}{self.fevr}/apiAuth"
        logit.execute(f"Authenticating with {fevrUrl}",src=self.script)
        apiAuth = self.rSession.post(f"{fevrUrl}", json=JsonPost)
        apiAuthJSON = json.loads(apiAuth.content)
        if apiAuthJSON['auth']:
            logit.execute(f"AUTH SUCCESS: source: {apiAuthJSON['authIP']} name: {apiAuthJSON['name']}",src=self.script)
        else:
            logit.execute(f"AUTH FAILURE: source:{apiAuthJSON['authIP']} name: {apiAuthJSON['name']}",src=self.script)
    
class fevrMQTT:
    def __init__(self):
        self.script = 'MQTT | client'
        hostname = socket.gethostname()
        self.clientID = f"fevr-{hostname}-{randint(0,100)}"
        self.verbose = False
        self.setupComplete = False
        try:
            self.setup()
            self.setupComplete = True
        except Exception as e:
            logit.execute(f"ERROR: {e}",src= self.script)
        try:
            if self.setupComplete:
                self.run()
        except socket.gaierror as e:
            if "Errno -2" in str(e):
                logit.execute(f"ERROR: MQTT Broker 'mqtt://{self.broker}:{self.port}' cannot be reached.")
        except Exception as e:
            logit.execute(f"ERROR: {e}",src= self.script)
            pass
    def getConfig(self,config):
        validConfig = True
        if path.isfile(config) and access(config, R_OK):
            with open(config) as configFile:
                try:
                    self.Config = yaml.safe_load(configFile)
                except:
                    self.Config = {}
                values = ['fevr_url','fevr_transport','mqtt_apikey','mqtt_broker','mqtt_port','mqtt_user','mqtt_password','mqtt_topics','verbose']
                validConfig=True
                for value in values:
                    try:
                        test = self.Config[value]
                    except KeyError:
                        validConfig=False
                        try:
                            missing +=f', {value}'
                        except UnboundLocalError:
                            missing = value
                msg = missing if missing else ""
                return {"valid": validConfig,"message": msg}
        else:
            if path.isfile(config):
                return "File Does not exist"
            return "File is not readable by user"
        
    def setup(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-c','--config',type=str,required=False,help="If set, uses command line options instead of the database (default: empty)")
        parser.set_defaults(db=True)
        parser.add_argument('-m','--mqtt',type=str,required=False,help="MQTT Broker IP/FQDN (default: mqtt)")
        parser.set_defaults(mqtt="mqtt")
        parser.add_argument('-k','--key',type=str,required=False,help="fEVR API Key (default: blank string)")
        parser.set_defaults(key="")
        parser.add_argument('-p','--port',type=int,required=False,help="MQTT Port (default: 1883)")
        parser.set_defaults(port=1883)
        parser.add_argument('-t','--topics',type=str,required=False,help="MQTT Topics (default: 'frigate/+')")
        parser.set_defaults(topics="frigate/+")
        parser.add_argument('-u','--user',type=str,required=False,help="MQTT Username (default: '')")
        parser.set_defaults(user="")
        parser.add_argument('-P','--password',type=str,required=False,help="MQTT Password (default: '')")
        parser.set_defaults(password="")
        parser.add_argument('-f','--fevr',type=str,required=False,help="fEVR IP Address/FQDN (default: '127.0.0.1:5090)")
        parser.set_defaults(fevr='127.0.0.1:5090')
        parser.add_argument('-s','--https',action='store_true',required=False,help="If set uses https:// for fEVR API Calls (default: False)")
        parser.set_defaults(https=False)
        parser.add_argument('-v','--verbose',action='store_true',required=False,help="If set, outputs verbosely to stdout")
        parser.set_defaults(verbose=False)
        args = parser.parse_args()
        
        excluded = None
        if args.config:
            if self.getConfig(args.config) == "valid":
                # Use defaults if yaml values are not set
                self.fevr = "localhost:5090" if not self.Config["fevr_host"] and self.Config["fevr_port"] else f"{self.Config['fevr_host']}:{self.Config['fevr_port']}"
                self.broker = "mqtt" if not self.Config["mqtt_broker"] else self.Config["mqtt_broker"]
                self.port = 1883 if not self.Config["mqtt_port"] else int(self.Config["mqtt_port"])
                self.username = "" if not self.Config["mqtt_user"] else self.Config["mqtt_user"]
                self.password = "" if not self.Config["mqtt_password"] else self.Config["mqtt_password"]
                self.apikey = "" if not self.Config["mqtt_apikey"] else self.Config["mqtt_apikey"]
                self.verbose = self.Config["verbose"]
                self.transport = "https://" if self.Config["fevr_transport"] == "https" or self.Config["fevr_transport"] == "https://" else "http://"
                topics = "frigate/+" if not self.Config["mqtt_topics"] else self.Config["mqtt_topics"]

                self.topics = []
                topics = topics.split(',',5)
                count=0
                for topic in topics:
                    if 4 >= count:
                        self.topics.append(topic)
                    else:
                        if 5 == count:
                            excluded = f"Topic Limit Exceeded. Excluded Topics: "
                        excluded += f"'{topic}' "
                # Set sane defaults
                if not self.fevr:
                    self.fevr = "localhost:5090"
        else:
            self.fevr = args.fevr
            self.broker = args.mqtt
            self.port = args.port
            self.username = args.user
            self.password = args.password
            self.apikey = args.key
            self.verbose = args.verbose

            topics = args.topics
            if args.https:
                self.transport = "https://"
            else:
                self.transport = "http://"
            self.topics = []
            topics = topics.split(',',5)
            count=0
            excluded = None
            for topic in topics:
                if 4 >= count:
                    self.topics.append(topic)
                else:
                    if 5 == count:
                        excluded = f"Topic Limit Exceeded. Excluded Topics: "
                    excluded += f"'{topic}' "
        if excluded:
            logit.execute(excluded,src=self.script)
        if self.verbose:
            if self.apikey:
                key=True
            logit.execute(f"fevr:{self.fevr} | broker: {self.broker} | port: {self.port} | user: {self.username} | password: {self.password} | https: {args.https} | apiKey: {key} | topics: {self.topics}", src=self.script)
    def connect_mqtt(self) -> mqtt_client:
        def on_connect(client, userdata, flags, rc):
                if rc == 0:
                    logit.execute(f"Connected to {self.broker}:{self.port} as {self.clientID}",src=self.script)
                    logit.execute(f"Subscribed to:{self.topics}".replace('[','\t').replace(']','').replace(', ','\t').replace("'",""),src=self.script)
                else:
                    logit.execute("Failed to connect, return code %d", rc,src=self.script)
        client = mqtt_client.Client(self.clientID)
        if self.username and self.password:
            client.username_pw_set(self.username, self.password)
        client.on_connect = on_connect
        client.connect(self.broker, self.port)
        return client
    def processMsg(self,msg,topic):
        if 'available' in topic:
            logit.execute('frigate is online',src=self.script)
        elif 'event' in topic:
            # Create Session to share cookies
            rSession = requests.Session()
            event = loads(msg)
            if self.verbose:
                eventfound = f"\n{json.dumps(event)}"
            else:
                eventfound = event["after"]["id"]
            eventtype = event["type"]
            logit.execute(f"EVENT ({eventtype}) FOUND: {eventfound}", src=self.script)
            
            after = event['after']
            if event['type'] == 'end':
                # Authenticate with API Key first...
                auth(transport=self.transport,apikey=self.apikey,fevr=self.fevr,rSession=rSession)
                # Populate Event Data
                Object = after['label']
                score = floor(float(after['score'])*100)
                camera = after['camera']
                eventid = after['id']
                # Calculate GET URL to submit
                fEVRurl = f"{self.transport}{self.fevr}/api/events/add/{eventid}/{camera}/{Object}/{score}"
                # Make it so
                addEventResponse = rSession.get(fEVRurl)
                # Read the response to a variable
                respJSON = json.loads(addEventResponse.content)
                # It's log, it's log, it's better than bad it's good.
                if self.verbose:
                    logit.execute(fEVRurl,src=self.script)
                if respJSON["error"] == 0:
                    logit.execute(f"SUCCESS: {eventid} ({Object} in {camera}) added",src=self.script)
                else:
                    logit.execute(f"FAILURE: {respJSON}",src=self.script)
    def subscribe(self, client: mqtt_client):
        def on_message(client, userdata, msg):
            ## This is where our code goes to do what we want when a message is received
            if self.verbose:
                logit.execute(f"{msg.topic}: Message Received",src=self.script)
            self.processMsg(msg.payload.decode(),msg.topic)
        for topic in self.topics:
            if self.verbose:
                logit.execute(f"Subscribed to: {topic}",src=self.script)
            client.subscribe(topic)
        client.on_message = on_message
    def run(self):
        self.client = self.connect_mqtt()
        self.subscribe(self.client)
        self.client.loop_forever()
if __name__ == '__main__':
    fevrMQTT()