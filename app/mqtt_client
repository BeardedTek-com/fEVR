#!/usr/bin/env python
#    This code is a portion of frigate Event Video Recorder (fEVR)
#
#    Copyright (C) 2021-2022  The Bearded Tek (http://www.beardedtek.com) William Kenny
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU AfferoGeneral Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

from urllib.parse import _NetlocResultMixinStr
from paho.mqtt import client as mqtt_client
import argparse
from os import path, access, R_OK
from time import time
from math import floor
from random import randint
import socket
import requests
from math import floor
import socket
import json
import yaml
import sys

class notifications:
    def __init__(self,config={}):
        self.config = config
        self.service = config['service']    # Which service to use
        self.cooldown = config['cooldown']  # Cooldown period so we don't overload notifications
        self.snap = None                    # Does Snapshot Exist?
        self.clip = None                    # Does Clip Exist
        self.event = None                   # Event dict from mqtt event
        self.lastnotification = 0
        self.source = f"MQTT | {self.service}"
        self.configured = False
    
    def setup(self):
        if self.service == "ntfy":
            try:
                self.ntfy()
                self.configured = True
            except Exception as error:
                pass
        entry = f"{self.service.title()} configured and ready" if self.configured else f"{self.service.title()} not configured.  Error: {error}"
        logit.execute(entry,src=self.source)
   
    def ntfy(self):
        self.source = "MQTT | ntfy"
        self.server = "https://ntfy.fevr.video"
        self.topic = "fEVR-hostname" # TODO: Get hostname from variable or system
        self.data = None
        self.headers =  {
                            "Title": "",
                            "Message": "",
                            "Priority": 3,
                            "Tags": None,
                            "Delay": None,
                            "Actions": None,
                            "Click": None,
                            "Attach": None,
                            "Filename": None,
                            "Email": None,
                            "Cache": None,
                            "Firebase": None,
                            "UnifiedPush": None,
                            "Poll-ID": None,
                            "Authorization": None
                        }
        
    def notify(self,method="post"):
        try:
            if method == "put":
                requests.put(self.server,data=self.data,headers=self.headers)
            elif method == "get":
                pass
            elif method == "post":
                requests.post(self.server,data=json.dumps(self.headers))
            self.lastnotification = int(time())
        except:
            logit.execute("Failed to send notification",src=self.source)

class logit:
    def execute(msg,src='fEVR',debug=True):
        def to_stderr(*a):
            print(*a, file=sys.stderr)
        logtime = "{:.2f}".format(time())
        logentry = f"{logtime} {str(msg)}"
        if debug:
            to_stderr(f"[ {src:16} ] {logentry}")

class getLocalIP:
    def __init__(self,url):
        if "://" in url:
            host = url.split(":")[1].replace("//","")
        else:
            host = "1.1.1.1"
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((host, 80))
        self.addr = s.getsockname()[0]

class auth:
    def __init__(self,url="http://localhost:5090",rSession=requests.Session(),apikey=""):
        self.url = url
        self.rSession = rSession
        self.apikey = apikey
        self.myip = getLocalIP(self.url)

    def api(self):
        source = "MQTT | AUTH"
        # Construct the json for the post request
        JsonPost = {'key':self.apikey,'ip':self.myip.addr}
        # Send the post using our session
        fevrUrl = f"{self.url}/apiAuth"
        apiAuth = self.rSession.post(f"{fevrUrl}", json=JsonPost)
        apiAuthJSON = json.loads(apiAuth.content)
        authResult = True if apiAuthJSON['auth'] else False
        logit.execute(f"{fevrUrl} {authResult}: {apiAuthJSON['authIP']} name: {apiAuthJSON['name']}",src=source)
        return authResult
    
class fevrMQTT:
    def __init__(self,configFile='data/config.yml'):
        self.source = "MQTT | DEFAULTS"
        hostname = socket.gethostname()
        self.clientID = f"fevr-{hostname}-{randint(0,100)}"
        # Initialize our Config variable as a dict and set sane default values in self.defaultConfig
        self.defaultConfig = {
                    "fevr":{
                            "url"  : "http://localhost:5090",
                            "name" : "fEVR"
                           },
                    "mqtt":{
                            "host"      : "mqtt",
                            "port"      : "1883",
                            "user"      : None,
                            "password"  : None,
                            "topics"    : ['frigate/+'],
                            "apikey"    : None
                           },
                    "notifications":{
                            "enabled": True,
                            "cooldown": 30,
                            "service": "ntfy",
                            "server": "https://ntfy.fevr.video",
                            "topic"     : f"fEVR-{socket.gethostname()}"
                           },
                    "verbose": True
        }
        # Get the Command Line Arguments in a dict
        self.Args = self.cla()
        # If using the -c/--config option, get the config from the specified file
        
        self.config = self.getConfig(self.Args['config']) if self.Args['config'] else self.getConfig(configFile)
        self.setup()
        self.run()
        
    def getConfig(self,config):
        source = "MQTT | CONFIG"
        if path.isfile(config) and access(config, R_OK):
            with open(config) as configFile:
                try:
                    Config = yaml.safe_load(configFile)
                except Exception as e:
                    logit.execute(f"ERROR: {e}",src=source)
                    Config = {}
            Config["error"] = None
        else:
            if path.isfile(config):
                Config["error"] = "File not readable"
            Config["error"] = "File does not exist"
        return self.validateConfig(Config)
    
    def validateConfig(self,Config={}):
        for key in ["mqtt","fevr","notifications","verbose"]:
            if key in Config:
                if key == "mqtt":
                    for subkey in ["host","port","user","password","topics","apikey"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "fevr":
                    for subkey in ["url"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]
                if key == "notifications":
                    for subkey in ["enabled","cooldown","service","server","topic"]:
                        if not subkey in Config[key]:
                            Config[key][subkey] = self.defaultConfig[key][subkey]            
            else:
                try:
                    Config[key] = self.defaultConfig[key]
                except:
                    Config[key] = None
        return Config
    
    def cla(self):
        source = "MQTT | CMDLINE"
        parser = argparse.ArgumentParser()
        parser.add_argument('-c','--config',type=str,required=False,help="If set, uses command line options instead of the database (default: empty)")
        parser.add_argument('-v','--verbose',action='store_true',required=False,help="If set, outputs verbosely to stdout")
        args = parser.parse_args()
        logit.execute(vars(args),src=source)
        return vars(args)
    
    def parseTopics(self):
        source = "MQTT | TOPICS"
        excluded = None
        Topics = self.config['mqtt']['topics'].split(',',5)
        topics = []
        count=0
        for topic in Topics:
            if 4 >= count:
                topics.append(topic)
            else:
                if 5 == count:
                    excluded = f"Topic Limit Exceeded. Excluded Topics: "
                excluded += f"'{topic}' "
        if excluded:
            logit.execute(f"Only 5 topics allowd.  Excluded Topics: {excluded}",src=source)
        return topics
    
    def setup(self):
        source = "MQTT | SETUP"
        
        # Parse the topics into a list if it's a string.
        if isinstance(self.config['mqtt']['topics'],str):
            self.config['mqtt']['topics'] = self.parseTopics()
            
        # Make a copy of self.config so we can hide secrets from the log
        displayConfig = self.config
        for key in displayConfig:
            if self.config['verbose']:
                displayConfig['mqtt']['apikey'] = True if displayConfig['mqtt']['apikey'] else False
            logit.execute(f"{key}: {displayConfig['key']}", src=source)
        
        #Setup Notifications:
        self.notify = notifications()
        self.notify.setup(config = self.config['notifications'])
        
    def connect_mqtt(self) -> mqtt_client:
        def on_connect(client, userdata, flags, rc):
            source = "MQTT | CONNECT"
            if rc == 0:
                logit.execute(f"Connected to {self.config['mqtt']['host']}:{self.config['mqtt']['port']} as {self.clientID}",src=source)
            else:
                logit.execute("Failed to connect, return code %d", rc,src=source)
        client = mqtt_client.Client(self.clientID)
        if self.config['mqtt']['user'] and self.config['mqtt']['password']:
            client.username_pw_set(self.config['mqtt']['user'], self.config['mqtt']['password'])
        client.on_connect = on_connect
        client.connect(self.config['mqtt']['host'], self.config['mqtt']['port'])
        return client
    
    def addEvent(self,event):
        #Adds an event to fEVR from frigate
        source = "MQTT | AddEvent"
        # Create a session variable, authenticate, and tell fEVR via it's API to get the event.
        rSession = requests.Session()
        Auth = auth(url=self.config['fevr']['url'],apikey=self.config['mqtt']['apikey'],rSession=rSession)
        if Auth.api():
            fEVRurl = f"{self.config['fevr']['url']}/api/events/add/{event['id']}/{event['camera']}/{event['label']}/{floor(float(event['score'])*100)}"
            addEventResponse = rSession.get(fEVRurl)
            respJSON = json.loads(addEventResponse.content)
            if self.config['verbose']:
                logit.execute(fEVRurl,src=source)
            if respJSON["error"] == 0:
                LogMsg = f"SUCCESS: {event['id']} ({event['label']} in {event['camera']}) added"
            else: 
                LogMsg = f"FAILURE: {respJSON}"
            logit.execute(LogMsg,src="MQTT | EVENT ADD")
        else:
            if fEVRurl:
                logit.execute(f"Failed to Authenticate - visit {fEVRurl}/profile to generate an API Auth Key and insert it in your config", src="MQTT | ERROR")
            else:
                logit.execute(f"It appears your instance of fEVR is not setup yet.  please visit `/setup` to complete setup.", src="MQTT | ERROR")
    
    def processMsg(self,msg,topic):
        '''
        If we receive a message from the server we check if it matches our watched topics
        If it does, we respond
        '''
        if 'available' in topic:
            source = "MQTT | status"
        # If frigate says its available, we output to the logs
            logit.execute('frigate is online',src=source)
        elif 'event' in topic:
            source = "MQTT | EVENT"
            # If it's an event we take action
            event = json.loads(msg)
            eventfound = f"\n{json.dumps(event)}" if self.config['verbose'] else event["after"]["id"]
            # Log the event
            if self.config['verbose']:
                logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            else:
                if event['type'] == "new" or event['type'] == "end":
                    logit.execute(f"{eventfound} ({event['type']})", src="MQTT | EVENT")
            # Take Action on the event
            if event['type'] == "new":
                # Trigger Notification
                if self.notify.config['enabled']:
                    if not self.notify.lastnotification or (int(time()) - self.notify.lastnotification) > self.notify.config['cooldown']:
                        self.notify.data = requests.get(f"self.config['fevr']['url']/api/cameras/{event['before']['camera']}/snapshot").content
                        self.notify.headers['Title'] = f"{self.config['fevr']['name']}: {event['before']['label'].title()} in {event['before']['camera']}"
                        self.notify.notify("put")
            elif event['type'] == 'end':
                # Use event['after'] to add event
                self.addEvent(event['after'])
                if self.notify.config['enabled']:
                    if not self.notify.lastnotification or (int(time()) - self.notify.lastnotification) > self.notify.config['cooldown']:
                        self.notify.data = requests.get(f"self.config['fevr']['url']/api/cameras/{event['before']['camera']}/clip").content
                        self.notify.headers['Title'] = f"{self.config['fevr']['name']}: {event['before']['label'].title()} in {event['before']['camera']}"
                        self.notify.notify("put")
    def subscribe(self, client: mqtt_client):
        def on_message(client, userdata, msg):
            source = "MQTT | RCVD"
            ## This is where our code goes to do what we want when a message is received
            if self.config['verbose']:
                logit.execute(f"{msg.topic}: Message Received",src=source)
            self.processMsg(msg.payload.decode(),msg.topic)
        for topic in self.config['mqtt']['topics']:
            source = "MQTT | SUBSCRIBE"
            logit.execute(f"Subscribing to: {topic}",src=source)
            client.subscribe(topic)
        client.on_message = on_message
    def run(self):
        self.client = self.connect_mqtt()
        self.subscribe(self.client)
        self.client.loop_forever()
if __name__ == '__main__':
    fevrMQTT()